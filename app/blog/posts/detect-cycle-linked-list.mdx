---
title: 'Data Structures & Algorithms - Linked List: Detect Cycle'
publishedAt: '2025-11-16'
---

Given `head`, the head of a linked list, determine if the linked list has a cycle in it.

There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the `next` pointer. 
Internally, `pos` is used to denote the index of the node that tail's `next` pointer is connected to. 
Note that `pos` is not passed as a parameter.

Return `true` if there is a cycle in the linked list. Otherwise, return `false`.

**Example 1:**

```
Input: head = [3,2,0,-4], pos = 1
Output: true
```

![detect-cycle-example](/detect-cycle.png)

**Playground:** [Leetcode 141](https://leetcode.com/problems/linked-list-cycle/description/)

---
### Approach 1: Visited Set

Iterate through the linked list and use a hash set to keep track of the visited nodes. 
During each iteration, check if the node is already in the set.
If yes, that node is the start of the cycle, otherwise add it and continue.

#### Algorithm

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

- hashSet = new HashSet();
- ListNode curr = head;

- while curr != null:
    - if curr in hashSet:
        - return true;
    - hashSet.add(curr);
    - curr = curr.next;

- return false;
```

#### Visualization

<DetectCycleVisitedSetVisualizer />

#### Time Complexity

We may iterate over the linked list once. Hence, overall time complexity = `O(n)`.

#### Space Complexity

The hash set will store at most `n` elements. Hence, overall space complexity = `O(n)`.

---
### Approach 2: Floyd Cycle Detection

A cycle in a linked list can be thought of as an infinite strip.
        
Assume you have two pointers on an infinite strip separated by a distance of `k` units. 
If you starting moving the first pointer (behind) by `2` units and the second pointer (ahead) by `1` unit, 
the distance between the two pointers will start decreasing by `1` unit in each iteration and will eventually reduce to `0`, 
i.e., the two pointers will collide.

<StripCollisionVisualizer />

### Algorithm

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */

- slow = head;
- fast = head;

// fast = null -> we are already at the end of the list
// fast.next = null -> we are at the last node, the list ends here
- while fast != null and fast.next != null: 
    - slow = slow.next;
    - fast = fast.next.next;

    - if slow == fast: return true; // cycle detected

- return false;
```

#### Visualization

<DetectCycleFloydVisualizer />

#### Time Complexity





